<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Portal Breaker – Random HP (1–10) Bricks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- ===== Embedded CSS ===== -->
  <style>
    /* ================= Reset & Box‐Sizing ================ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* ================= Body Styling ================= */
    body {
      background: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
      touch-action: none; /* Prevent mobile scrolling */
    }

    /* ================= Overlays (menus, game‐over) ================= */
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .overlay.hidden {
      display: none;
    }
    .overlay h1, .overlay h2 {
      margin-bottom: 20px;
      font-size: 32px;
    }
    .overlay p {
      margin: 10px;
      font-size: 18px;
      text-align: center;
      max-width: 80%;
    }

    /* ================= Buttons ================= */
    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 18px;
      cursor: pointer;
      border: none;
      background: #e67e22;
      color: #fff;
      border-radius: 5px;
      transition: transform 0.1s;
    }
    button:hover {
      transform: scale(1.1);
    }
    button:active {
      transform: scale(1.0);
    }

    /* ================= Canvas ================= */
    #gameCanvas {
      display: block;
      margin: auto;
      background: #f0f0f0;
      border: 3px solid #333;
    }

    /* ================= HUD ================= */
    .hud {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 18px;
      color: #000;
    }
  </style>
</head>
<body>
  <!-- ===== Overlays ===== -->
  <div id="menuScreen" class="overlay hidden">
    <h1>Portal Breaker</h1>
    <button id="playBtn">Play</button>
    <button id="howToBtn">How to Play</button>
    <button id="settingsBtn">Settings</button>
    <button id="creditsBtn">Credits</button>
  </div>

  <div id="howToScreen" class="overlay hidden">
    <h2>How to Play</h2>
    <p>
      1. Click (or tap) anywhere except on a brick to place <strong>Portal A</strong> (entry – blue).<br />
      2. Click again (except on bricks) to place <strong>Portal B</strong> (exit – orange).<br />
      3. After Portal B is placed, click‐and‐drag <strong>inside</strong> Portal B’s rectangle to freely set its exit angle. Release to stop rotating.<br />
      4. Finally, click outside both portals/bricks to fire three balls at once (one straight, ±0.1 rad).<br />
      Balls that enter Portal A teleport to Portal B’s center and emerge at the chosen angle.
    </p>
    <button class="backBtn">Back</button>
  </div>

  <div id="settingsScreen" class="overlay hidden">
    <h2>Settings</h2>
    <p>No sound or music for now.</p>
    <button class="backBtn">Back</button>
  </div>

  <div id="creditsScreen" class="overlay hidden">
    <h2>Credits</h2>
    <p>Developed by: Your Name</p>
    <button class="backBtn">Back</button>
  </div>

  <!-- ===== Game Canvas ===== -->
  <canvas id="gameCanvas" width="480" height="640"></canvas>

  <!-- ===== Game Over / Win Screen ===== -->
  <div id="gameOverScreen" class="overlay hidden">
    <h2 id="gameOverText">Game Over</h2>
    <p id="finalScore">Score: 0</p>
    <button id="restartBtn">Restart</button>
    <button id="menuBtn">Main Menu</button>
  </div>

  <!-- ===== Embedded JavaScript ===== -->
  <script>
    // =========================
    // Portal Breaker – Random HP (1–10) Bricks
    // =========================

    // ====== 1. Canvas & Context Setup ======
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;

    // ====== 2. Game State Variables ======
    let gameState = "placingPortals";
    let score = 0;
    let lives = 3;

    let bricks = [];
    let portalA = null;   // Entry portal (blue)
    let portalB = null;   // Exit portal (orange)
    let allowFiring = false;

    let cannon, paddle;
    let balls = [];

    const BRICK_WIDTH = 60;
    const BRICK_HEIGHT = 20;
    const BRICK_MARGIN = 5;

    // Flag for rotating Portal B
    let isRotatingB = false;

    // =========================
    // 3. Classes for Game Objects
    // =========================

    // 3.1 Ball Class
    class Ball {
      constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 5;
        this.active = true;
        this.justTeleported = false;
      }

      update(delta) {
        if (!this.active) return;

        // Move
        this.x += this.vx * delta;
        this.y += this.vy * delta;

        // Wall collisions (left/right)
        if (this.x - this.radius <= 0 || this.x + this.radius >= WIDTH) {
          this.vx *= -1;
        }
        // Ceiling collision
        if (this.y - this.radius <= 0) {
          this.vy *= -1;
        }

        // Paddle collision (bottom)
        if (this.y + this.radius >= HEIGHT) {
          if (
            paddle &&
            this.x >= paddle.x &&
            this.x <= paddle.x + paddle.width
          ) {
            this.vy *= -1;
            this.y = HEIGHT - this.radius - paddle.height;
          } else {
            this.active = false;
            lives--;
            console.log("Ball missed paddle → lives =", lives);
            if (lives <= 0) {
              endGame(false);
            }
          }
        }

        // Brick collisions
        bricks.forEach((brick) => {
          if (brick.hp > 0 && brick.collidesWith(this)) {
            brick.onHit();
            const prevX = this.x - this.vx * delta;
            const prevY = this.y - this.vy * delta;
            if (
              prevY + this.radius <= brick.y ||
              prevY - this.radius >= brick.y + BRICK_HEIGHT
            ) {
              this.vy *= -1;
            } else {
              this.vx *= -1;
            }
            score += 100 * (brick.initialHP); 
            // You can award points differently; here we give 100×initial HP for each hit.
            console.log("Hit brick → score =", score);
          }
        });
        // Remove bricks with hp ≤ 0
        bricks = bricks.filter((b) => b.hp > 0);

        // Portal A collision (one‐way)
        if (
          portalA &&
          portalB &&
          !this.justTeleported &&
          portalA.collidesWith(this)
        ) {
          this.teleportToPortalB();
        }

        // Win condition
        if (bricks.length === 0) {
          endGame(true);
        }
      }

      teleportToPortalB() {
        console.log("Ball entered Portal A → teleport to Portal B");
        const angle = portalB.exitAngle;
        const speedBoost = 150;
        const offset = this.radius + 2;
        const cx = portalB.x + portalB.width / 2;
        const cy = portalB.y + portalB.height / 2;

        this.x = cx + Math.cos(angle) * offset;
        this.y = cy + Math.sin(angle) * offset;

        const baseSpeed = Math.hypot(this.vx, this.vy) + speedBoost;
        this.vx = Math.cos(angle) * baseSpeed;
        this.vy = Math.sin(angle) * baseSpeed;

        this.justTeleported = true;
        setTimeout(() => {
          this.justTeleported = false;
        }, 150);
      }

      draw(ctx) {
        if (!this.active) return;
        ctx.beginPath();
        ctx.fillStyle = "#000";
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // 3.2 Paddle Class
    class Paddle {
      constructor() {
        this.width = 100;
        this.height = 10;
        this.x = (WIDTH - this.width) / 2;
        this.y = HEIGHT - this.height;
      }
      draw(ctx) {
        ctx.fillStyle = "#8e44ad";
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    // 3.3 Brick Class (random HP 1–10)
    class Brick {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.initialHP = Math.floor(Math.random() * 10) + 1; // 1–10
        this.hp = this.initialHP;
        this.width = BRICK_WIDTH;
        this.height = BRICK_HEIGHT;
      }

      collidesWith(ball) {
        const distX = Math.abs(ball.x - (this.x + this.width / 2));
        const distY = Math.abs(ball.y - (this.y + this.height / 2));
        if (
          distX > this.width / 2 + ball.radius ||
          distY > this.height / 2 + ball.radius
        ) {
          return false;
        }
        return true;
      }

      onHit() {
        this.hp--;
        console.log("Brick HP →", this.hp);
      }

      draw(ctx) {
        // Fill brick in red
        ctx.fillStyle = "#e74c3c";
        ctx.fillRect(this.x, this.y, this.width, this.height);

        // Draw black border
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1;
        ctx.strokeRect(this.x, this.y, this.width, this.height);

        // Draw hit‐count in white at center
        ctx.fillStyle = "#fff";
        ctx.font = "16px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const text = String(this.hp <= 0 ? 0 : this.hp);
        const cx = this.x + this.width / 2;
        const cy = this.y + this.height / 2;
        ctx.fillText(text, cx, cy);
      }
    }

    // 3.4 Portal Class
    class Portal {
      constructor(x, y, type) {
        this.x = Math.floor(x / 10) * 10;
        this.y = Math.floor(y / 10) * 10;
        this.width = BRICK_WIDTH;
        this.height = BRICK_HEIGHT;
        this.type = type; // "A" or "B"
        if (type === "B") {
          this.exitAngle = -Math.PI / 2; // default up
        } else {
          this.exitAngle = null;
        }
      }

      collidesWith(ball) {
        return (
          ball.x >= this.x &&
          ball.x <= this.x + this.width &&
          ball.y >= this.y &&
          ball.y <= this.y + this.height
        );
      }

      draw(ctx) {
        if (this.type === "A") {
          ctx.fillStyle = "#0064ff"; // blue entry
        } else {
          ctx.fillStyle = "#ff6400"; // orange exit
        }
        ctx.globalAlpha = 0.5;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.globalAlpha = 1;

        // Draw arrow on exit portal
        if (this.type === "B") {
          const cx = this.x + this.width / 2;
          const cy = this.y + this.height / 2;
          const len = this.width / 2 - 4;
          const ax = cx + Math.cos(this.exitAngle) * len;
          const ay = cy + Math.sin(this.exitAngle) * len;

          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(ax, ay);
          ctx.stroke();

          ctx.fillStyle = "#fff";
          ctx.beginPath();
          const arrowSize = 6;
          const theta = this.exitAngle;
          const back1 = theta + Math.PI - 0.4;
          const back2 = theta + Math.PI + 0.4;
          ctx.moveTo(cx + Math.cos(theta) * len, cy + Math.sin(theta) * len);
          ctx.lineTo(
            cx + Math.cos(back1) * arrowSize + Math.cos(theta) * len,
            cy + Math.sin(back1) * arrowSize + Math.sin(theta) * len
          );
          ctx.lineTo(
            cx + Math.cos(back2) * arrowSize + Math.cos(theta) * len,
            cy + Math.sin(back2) * arrowSize + Math.sin(theta) * len
          );
          ctx.closePath();
          ctx.fill();
        }
      }
    }

    // 3.5 Cannon Class
    class Cannon {
      constructor() {
        this.x = WIDTH / 2;
        this.y = HEIGHT - 30;
        this.angle = -Math.PI / 2;
      }
      aim(pointerX) {
        const dx = pointerX - this.x;
        const dy = 0 - this.y;
        this.angle = Math.atan2(dy, dx);
        if (this.angle < -Math.PI) this.angle = -Math.PI;
        if (this.angle > 0) this.angle = 0;
      }
      draw(ctx) {
        ctx.fillStyle = "#7f8c8d";
        ctx.fillRect(this.x - 20, this.y, 40, 20);

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = "#34495e";
        ctx.fillRect(0, -5, 40, 10);
        ctx.restore();

        ctx.strokeStyle = "rgba(0,0,0,0.3)";
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        const endX = this.x + Math.cos(this.angle) * 100;
        const endY = this.y + Math.sin(this.angle) * 100;
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // =========================
    // 4. Helper Functions
    // =========================

    // Place Portal A or B if clicking outside bricks
    function placePortal(x, y) {
      // Don’t place on a brick
      for (const b of bricks) {
        if (
          x >= b.x &&
          x <= b.x + b.width &&
          y >= b.y &&
          y <= b.y + b.height
        ) {
          return;
        }
      }
      if (!portalA) {
        portalA = new Portal(x - BRICK_WIDTH / 2, y - BRICK_HEIGHT / 2, "A");
        console.log("PLACED Portal A at", portalA.x, portalA.y);
      } else if (!portalB) {
        portalB = new Portal(x - BRICK_WIDTH / 2, y - BRICK_HEIGHT / 2, "B");
        console.log(
          "PLACED Portal B at",
          portalB.x,
          portalB.y,
          "exitAngle=",
          portalB.exitAngle.toFixed(2)
        );
        allowFiring = true;
        gameState = "playing";
      }
    }

    // Fire three balls at once (spread ±0.1 rad)
    function fireBalls() {
      const baseAngle = cannon.angle;
      const speed = 300;
      const spreads = [0, 0.1, -0.1];
      balls = spreads.map((dθ) => {
        const ang = baseAngle + dθ;
        const vx = Math.cos(ang) * speed;
        const vy = Math.sin(ang) * speed;
        const spawnX = cannon.x + Math.cos(baseAngle) * 40;
        const spawnY = cannon.y + Math.sin(baseAngle) * 40;
        console.log(
          "FIRED ball (dθ=",
          dθ.toFixed(2),
          ") vx,vy=",
          vx.toFixed(2),
          vy.toFixed(2)
        );
        return new Ball(spawnX, spawnY, vx, vy);
      });
    }

    // Build brick layout with random HP 1–10
    function setupBricks() {
      bricks = [];
      for (let row = 0; row < 3; row++) {
        const y = 40 + row * (BRICK_HEIGHT + BRICK_MARGIN);
        for (let i = 0; i < 7; i++) {
          const x = 40 + i * (BRICK_WIDTH + BRICK_MARGIN);
          bricks.push(new Brick(x, y));
        }
      }
    }

    // End the game: show “You Win!” or “Game Over”
    function endGame(win) {
      gameState = "gameover";
      canvas.classList.add("hidden");
      document.getElementById("gameOverScreen").classList.remove("hidden");
      document.getElementById("gameOverText").textContent = win ? "You Win!" : "Game Over";
      document.getElementById("finalScore").textContent = "Score: " + score;
    }

    // =========================
    // 5. Initialization & Main Loop
    // =========================

    function initGame() {
      score = 0;
      lives = 3;
      portalA = null;
      portalB = null;
      allowFiring = false;
      setupBricks();
      cannon = new Cannon();
      paddle = new Paddle();
      balls = [];
      gameState = "placingPortals";

      document.getElementById("menuScreen").classList.add("hidden");
      document.getElementById("gameOverScreen").classList.add("hidden");
      canvas.classList.remove("hidden");

      draw(); // draw immediately so you see bricks+cannon right away
    }

    let lastTime = 0;
    function gameLoop(time) {
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      if (gameState === "playing") {
        balls.forEach((b) => b.update(delta));
        balls = balls.filter((b) => b.active);
      }

      draw(); // always redraw each frame
      requestAnimationFrame(gameLoop);
    }

    // Draw all game elements
    function draw() {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);

      // Draw bricks
      bricks.forEach((b) => b.draw(ctx));

      // Draw portals if placed
      if (portalA) portalA.draw(ctx);
      if (portalB) portalB.draw(ctx);

      // Draw cannon & paddle
      cannon.draw(ctx);
      paddle.draw(ctx);

      // Draw balls
      balls.forEach((b) => b.draw(ctx));

      // Draw HUD: score & lives
      ctx.fillStyle = "#000";
      ctx.font = "18px sans-serif";
      ctx.fillText("Score: " + score, 10, 20);
      ctx.fillText("Lives: " + lives, 350, 20);
    }

    // Utility to get X & Y from event
    function getPointerX(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.touches && e.touches[0]) return e.touches[0].clientX - rect.left;
      else return e.clientX - rect.left;
    }
    function getPointerY(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.touches && e.touches[0]) return e.touches[0].clientY - rect.top;
      else return e.clientY - rect.top;
    }

    // =========================
    // 6. Pointer (Mouse/Touch) Handlers
    // =========================

    // 6.1 pointerdown
    canvas.addEventListener(
      "pointerdown",
      (e) => {
        const x = getPointerX(e);
        const y = getPointerY(e);
        console.log("pointerdown at", x.toFixed(2), y.toFixed(2), "state=", gameState);

        if (gameState === "placingPortals") {
          // If inside Portal B, begin rotating
          if (
            portalB &&
            x >= portalB.x &&
            x <= portalB.x + portalB.width &&
            y >= portalB.y &&
            y <= portalB.y + portalB.height
          ) {
            isRotatingB = true;
            setPortalBAngleFromPointer(x, y);
            return;
          }
          // Otherwise, place Portal A or B
          placePortal(x, y);
        } else if (gameState === "playing") {
          // If inside Portal B, begin rotating
          if (
            portalB &&
            x >= portalB.x &&
            x <= portalB.x + portalB.width &&
            y >= portalB.y &&
            y <= portalB.y + portalB.height
          ) {
            isRotatingB = true;
            setPortalBAngleFromPointer(x, y);
            return;
          }
          // Else: do nothing on pointerdown; firing will happen on pointerup if outside B
        }
      },
      false
    );

    // 6.2 pointermove
    canvas.addEventListener(
      "pointermove",
      (e) => {
        if (isRotatingB && portalB) {
          const x = getPointerX(e);
          const y = getPointerY(e);
          setPortalBAngleFromPointer(x, y);
        } else if (gameState === "placingPortals" || gameState === "playing") {
          const x = getPointerX(e);
          cannon.aim(x);
          paddle.x = x - paddle.width / 2;
        }
      },
      false
    );

    // 6.3 pointerup
    canvas.addEventListener(
      "pointerup",
      (e) => {
        const x = getPointerX(e);
        const y = getPointerY(e);
        console.log("pointerup at", x.toFixed(2), y.toFixed(2), "state=", gameState);

        if (isRotatingB) {
          isRotatingB = false;
          return;
        }

        if (gameState === "playing" && allowFiring) {
          // Check if pointerup is outside bricks and outside Portal B
          let insideBrick = false;
          for (const b of bricks) {
            if (
              x >= b.x &&
              x <= b.x + b.width &&
              y >= b.y &&
              y <= b.y + b.height
            ) {
              insideBrick = true;
              break;
            }
          }
          let insideB = false;
          if (
            portalB &&
            x >= portalB.x &&
            x <= portalB.x + portalB.width &&
            y >= portalB.y &&
            y <= portalB.y + portalB.height
          ) {
            insideB = true;
          }
          if (!insideBrick && !insideB) {
            fireBalls();
          }
        }
      },
      false
    );

    // Compute portalB.exitAngle from pointer coords
    function setPortalBAngleFromPointer(px, py) {
      if (!portalB) return;
      const cx = portalB.x + portalB.width / 2;
      const cy = portalB.y + portalB.height / 2;
      portalB.exitAngle = Math.atan2(py - cy, px - cx);
      console.log("Portal B exitAngle =", portalB.exitAngle.toFixed(2));
    }

    // =========================
    // 7. UI Button Handlers
    // =========================

    document.getElementById("playBtn").addEventListener("click", () => {
      initGame();
    });
    document.getElementById("restartBtn").addEventListener("click", () => {
      initGame();
    });
    document.getElementById("menuBtn").addEventListener("click", () => {
      gameState = "menu";
      document.getElementById("gameOverScreen").classList.add("hidden");
      document.getElementById("menuScreen").classList.remove("hidden");
    });
    document.querySelectorAll(".backBtn").forEach((btn) => {
      btn.addEventListener("click", () => {
        document.getElementById("howToScreen").classList.add("hidden");
        document.getElementById("settingsScreen").classList.add("hidden");
        document.getElementById("creditsScreen").classList.add("hidden");
        document.getElementById("menuScreen").classList.remove("hidden");
      });
    });
    document.getElementById("howToBtn").addEventListener("click", () => {
      document.getElementById("menuScreen").classList.add("hidden");
      document.getElementById("howToScreen").classList.remove("hidden");
    });
    document.getElementById("settingsBtn").addEventListener("click", () => {
      document.getElementById("menuScreen").classList.add("hidden");
      document.getElementById("settingsScreen").classList.remove("hidden");
    });
    document.getElementById("creditsBtn").addEventListener("click", () => {
      document.getElementById("menuScreen").classList.add("hidden");
      document.getElementById("creditsScreen").classList.remove("hidden");
    });

    // =========================
    // 8. Start the Game
    // =========================

    initGame();
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
