<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Portal Breaker – Paddle Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    /* ===== Full‐Screen Setup ===== */
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      background: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none; /* Prevent mobile scroll on canvas touches */
    }

    /* ===== “Place Portals” Button ===== */
    #placePortalsBtn {
      margin: 8px 0;
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      background: #3498db;
      color: white;
      border-radius: 4px;
      transition: transform 0.1s;
      z-index: 10;
    }
    #placePortalsBtn:hover { transform: scale(1.05); }
    #placePortalsBtn:active { transform: scale(1.0); }

    /* ===== Canvas Container ===== */
    #canvasContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    #gameCanvas {
      max-width: 100%;
      max-height: 100%;
      background: #f0f0f0;
      image-rendering: pixelated;
    }

    /* ===== Overlay (Game Over) ===== */
    .overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    .overlay.hidden { display: none; }
    .overlay h2, .overlay p {
      color: white;
      margin-bottom: 20px;
      text-align: center;
    }
    .overlay button {
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      border: none;
      background: #e67e22;
      color: white;
      border-radius: 5px;
      transition: transform 0.1s;
    }
    .overlay button:hover { transform: scale(1.05); }
    .overlay button:active { transform: scale(1.0); }
  </style>
</head>
<body>
  <!-- “Place Portals” Button -->
  <button id="placePortalsBtn">Place Portals</button>

  <!-- Canvas Container with 480×640 Canvas inside -->
  <div id="canvasContainer">
    <canvas id="gameCanvas" width="480" height="640"></canvas>
  </div>

  <!-- Game Over Overlay -->
  <div id="gameOverScreen" class="overlay hidden">
    <h2 id="gameOverText">Game Over</h2>
    <p id="finalScore">Score: 0</p>
    <button id="restartBtn">Restart</button>
  </div>

  <script>
    // ============================
    // Portal Breaker – Enhanced Paddle Control
    // ============================
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const VIRTUAL_WIDTH = 480;
    const VIRTUAL_HEIGHT = 640;

    // ======= Game State =======
    let gameState = "playing";  // "playing" or "gameover"
    let lives = 1;
    let extraLives = 0;
    let score = 0;

    let bricks = [];
    let portalA = null;
    let portalB = null;
    let allowFiring = false;

    let cannon = null;
    let paddle = null;
    let ball = null;   // Will be a Ball instance once fired

    let portalPlacementActive = false;
    let nextPortalType = "A"; // "A" first, then "B"
    let isRotatingB = false;
    let skipNextFire = false; // Skip one tap right after placing a portal

    const BRICK_WIDTH = 60;
    const BRICK_HEIGHT = 20;
    const BRICK_MARGIN = 5;

    // ======= Classes =======

    // 1) Ball
    class Ball {
      constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 5;
        this.active = true;
        this.justTeleported = false;
      }
      update(delta) {
        if (!this.active) return;

        // Move
        this.x += this.vx * delta;
        this.y += this.vy * delta;

        // Wall collisions (left/right)
        if (this.x - this.radius <= 0 || this.x + this.radius >= VIRTUAL_WIDTH) {
          this.vx *= -1;
        }
        // Ceiling collision (top)
        if (this.y - this.radius <= 0) {
          this.vy *= -1;
        }

        // Bottom / Paddle (with enhanced angle control)
        if (this.y + this.radius >= VIRTUAL_HEIGHT) {
          if (
            paddle &&
            this.x >= paddle.x &&
            this.x <= paddle.x + paddle.width
          ) {
            // Compute horizontal offset from paddle center: range [-1..1]
            const paddleCenter = paddle.x + paddle.width / 2;
            const relativeHit = (this.x - paddleCenter) / (paddle.width / 2);
            // Cap relativeHit to [-1, +1]
            const clamped = Math.max(-1, Math.min(1, relativeHit));
            // Choose a max horizontal speed:
            const maxHoriz = 300;
            // Assign new vx based on how far from center you hit:
            this.vx = clamped * maxHoriz;
            // Always send upward:
            this.vy = -Math.abs(this.vy);
            // Nudge ball up so it doesn't stick
            this.y = VIRTUAL_HEIGHT - this.radius - paddle.height;
          } else {
            // Ball is lost
            this.active = false;
            lives--;
            if (lives > 0) {
              respawnCannon();
            } else if (extraLives > 0) {
              extraLives--;
              lives = 1;
              respawnCannon();
            } else {
              endGame(false);
            }
          }
        }

        // Brick collisions
        for (const brick of bricks) {
          if (
            (brick.isExtra && !brick.collected) || 
            (!brick.isExtra && brick.hp > 0)
          ) {
            if (brick.collidesWith(this)) {
              if (brick.isExtra && !brick.collected) {
                extraLives++;
                brick.collected = true;
                score += 200;
              } else {
                brick.onHit();
                score += 100 * brick.initialHP;
              }
              this.reflect(brick, delta);
            }
          }
        }
        // Remove destroyed normal bricks or collected extras
        bricks = bricks.filter(b => {
          if (b.isExtra) return !b.collected;
          return b.hp > 0;
        });

        // Portal A → teleport to B
        if (
          portalA !== null &&
          portalB !== null &&
          !this.justTeleported &&
          portalA.collidesWith(this)
        ) {
          this.teleportToPortalB();
        }

        // Win condition: no normal bricks left
        const normalLeft = bricks.filter(b => !b.isExtra).length;
        if (normalLeft === 0) {
          endGame(true);
        }
      }
      reflect(brick, delta) {
        // Determine reflection axis by checking previous position
        const prevX = this.x - this.vx * delta;
        const prevY = this.y - this.vy * delta;
        if (
          prevY + this.radius <= brick.y ||
          prevY - this.radius >= brick.y + BRICK_HEIGHT
        ) {
          this.vy *= -1;
        } else {
          this.vx *= -1;
        }
      }
      teleportToPortalB() {
        const angle = portalB.exitAngle;
        const speedBoost = 150;
        const offset = this.radius + 2;
        const cx = portalB.x + portalB.width / 2;
        const cy = portalB.y + portalB.height / 2;
        // Move ball just outside Portal B
        this.x = cx + Math.cos(angle) * offset;
        this.y = cy + Math.sin(angle) * offset;
        // Increase speed
        const baseSpeed = Math.hypot(this.vx, this.vy) + speedBoost;
        this.vx = Math.cos(angle) * baseSpeed;
        this.vy = Math.sin(angle) * baseSpeed;
        this.justTeleported = true;
        setTimeout(() => { this.justTeleported = false; }, 150);
      }
      draw(ctx) {
        if (!this.active) return;
        ctx.beginPath();
        ctx.fillStyle = "#000";
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // 2) Paddle
    class Paddle {
      constructor() {
        this.width = 100;
        this.height = 10;
        this.x = (VIRTUAL_WIDTH - this.width) / 2;
        this.y = VIRTUAL_HEIGHT - this.height;
      }
      draw(ctx) {
        ctx.fillStyle = "#8e44ad";
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    // 3) Brick
    class Brick {
      constructor(x, y, isExtra = false) {
        this.x = x;
        this.y = y;
        this.isExtra = isExtra;
        this.initialHP = isExtra ? 1 : (Math.floor(Math.random() * 10) + 1);
        this.hp = this.initialHP;
        this.width = BRICK_WIDTH;
        this.height = BRICK_HEIGHT;
        this.collected = false; // for extra life bricks
      }
      collidesWith(ball) {
        const distX = Math.abs(ball.x - (this.x + this.width / 2));
        const distY = Math.abs(ball.y - (this.y + this.height / 2));
        return !(
          distX > this.width / 2 + ball.radius ||
          distY > this.height / 2 + ball.radius
        );
      }
      onHit() {
        if (!this.isExtra) this.hp--;
      }
      draw(ctx) {
        ctx.fillStyle = this.isExtra ? "#2ecc71" : "#e74c3c";
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1;
        ctx.strokeRect(this.x, this.y, this.width, this.height);
        ctx.fillStyle = "#fff";
        ctx.font = "16px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const text = this.isExtra ? "★" : String(this.hp <= 0 ? 0 : this.hp);
        ctx.fillText(text, this.x + this.width / 2, this.y + this.height / 2);
      }
    }

    // 4) Portal
    class Portal {
      constructor(x, y, type) {
        this.x = Math.floor(x / 10) * 10;
        this.y = Math.floor(y / 10) * 10;
        this.width = BRICK_WIDTH;
        this.height = BRICK_HEIGHT;
        this.type = type; // "A" or "B"
        this.exitAngle = (type === "B") ? -Math.PI / 2 : null;
      }
      collidesWith(ball) {
        return (
          ball.x >= this.x &&
          ball.x <= this.x + this.width &&
          ball.y >= this.y &&
          ball.y <= this.y + this.height
        );
      }
      draw(ctx) {
        ctx.fillStyle = this.type === "A" ? "#0064ff" : "#ff6400";
        ctx.globalAlpha = 0.5;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.globalAlpha = 1;
        if (this.type === "B") {
          const cx = this.x + this.width / 2;
          const cy = this.y + this.height / 2;
          const len = this.width / 2 - 4;
          const ax = cx + Math.cos(this.exitAngle) * len;
          const ay = cy + Math.sin(this.exitAngle) * len;
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(ax, ay);
          ctx.stroke();
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          const arrowSize = 6;
          const theta = this.exitAngle;
          const back1 = theta + Math.PI - 0.4;
          const back2 = theta + Math.PI + 0.4;
          ctx.moveTo(cx + Math.cos(theta) * len, cy + Math.sin(theta) * len);
          ctx.lineTo(
            cx + Math.cos(back1) * arrowSize + Math.cos(theta) * len,
            cy + Math.sin(back1) * arrowSize + Math.sin(theta) * len
          );
          ctx.lineTo(
            cx + Math.cos(back2) * arrowSize + Math.cos(theta) * len,
            cy + Math.sin(back2) * arrowSize + Math.sin(theta) * len
          );
          ctx.closePath();
          ctx.fill();
        }
      }
    }

    // 5) Cannon
    class Cannon {
      constructor() {
        this.x = VIRTUAL_WIDTH / 2;
        this.y = VIRTUAL_HEIGHT - 30;
        this.angle = -Math.PI / 2;
        this.visible = true;
      }
      aim(pointerX) {
        this.angle = Math.atan2(0 - this.y, pointerX - this.x);
        if (this.angle < -Math.PI) this.angle = -Math.PI;
        if (this.angle > 0) this.angle = 0;
      }
      draw(ctx) {
        if (!this.visible) return;
        ctx.fillStyle = "#7f8c8d";
        ctx.fillRect(this.x - 20, this.y, 40, 20);
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = "#34495e";
        ctx.fillRect(0, -5, 40, 10);
        ctx.restore();
        ctx.strokeStyle = "rgba(0,0,0,0.3)";
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        const endX = this.x + Math.cos(this.angle) * 100;
        const endY = this.y + Math.sin(this.angle) * 100;
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // ======= Helper Functions =======

    function placePortalAnytime(x, y) {
      // If (x,y) overlaps any brick, reject
      for (const b of bricks) {
        if (
          x >= b.x && x <= b.x + b.width &&
          y >= b.y && y <= b.y + b.height
        ) {
          return false;
        }
      }
      if (nextPortalType === "A") {
        portalA = new Portal(x - BRICK_WIDTH / 2, y - BRICK_HEIGHT / 2, "A");
        nextPortalType = "B";
        placePortalsBtn.textContent = "Place Portal B";
      } else {
        portalB = new Portal(x - BRICK_WIDTH / 2, y - BRICK_HEIGHT / 2, "B");
        allowFiring = true;
        portalPlacementActive = false;
        placePortalsBtn.textContent = "Place Portals";
      }
      skipNextFire = true; // skip next tap so we don’t fire immediately
      return true;
    }

    function fireBall() {
      if (portalA === null || portalB === null) return;
      const speed = 300;
      const vx = Math.cos(cannon.angle) * speed;
      const vy = Math.sin(cannon.angle) * speed;
      const spawnX = cannon.x + Math.cos(cannon.angle) * 40;
      const spawnY = cannon.y + Math.sin(cannon.angle) * 40;
      ball = new Ball(spawnX, spawnY, vx, vy);
      cannon.visible = false;
      allowFiring = false;
    }

    function setupBricks() {
      bricks = [];
      for (let row = 0; row < 3; row++) {
        const y = 40 + row * (BRICK_HEIGHT + BRICK_MARGIN);
        for (let i = 0; i < 7; i++) {
          const x = 40 + i * (BRICK_WIDTH + BRICK_MARGIN);
          bricks.push(new Brick(x, y));
        }
      }
      // Pick one random brick to be the extra‐life brick
      const idx = Math.floor(Math.random() * bricks.length);
      bricks[idx].isExtra = true;
      bricks[idx].hp = 1;
      bricks[idx].initialHP = 1;
    }

    function endGame(win) {
      gameState = "gameover";
      canvas.style.pointerEvents = "none";
      document.getElementById("gameOverScreen").classList.remove("hidden");
      document.getElementById("gameOverText").textContent = win ? "You Win!" : "Game Over";
      document.getElementById("finalScore").textContent = "Score: " + score;
    }

    function respawnCannon() {
      cannon.visible = true;
      allowFiring = true;
      ball = null;
    }

    function initGame() {
      lives = 1;
      extraLives = 0;
      score = 0;
      portalA = null;
      portalB = null;
      allowFiring = false;
      portalPlacementActive = false;
      nextPortalType = "A";
      skipNextFire = false;
      cannon = new Cannon();
      paddle = new Paddle();
      ball = null;
      setupBricks();
      gameState = "playing";
      canvas.style.pointerEvents = "auto";
      document.getElementById("gameOverScreen").classList.add("hidden");
      draw(); // initial draw
    }

    let lastTime = 0;
    function gameLoop(time) {
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      if (gameState === "playing") {
        // Only update if ball exists AND is still active:
        if (ball && ball.active) {
          ball.update(delta);
        }
        // If ball exists but just became inactive, clear it out:
        else if (ball && !ball.active) {
          ball = null;
        }
      }

      draw();
      requestAnimationFrame(gameLoop);
    }

    function draw() {
      ctx.clearRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);

      // Draw bricks
      for (const b of bricks) {
        b.draw(ctx);
      }

      // Draw portals
      if (portalA) portalA.draw(ctx);
      if (portalB) portalB.draw(ctx);

      // Draw cannon & paddle
      if (cannon) cannon.draw(ctx);
      if (paddle) paddle.draw(ctx);

      // Draw ball if it exists
      if (ball) ball.draw(ctx);

      // Draw HUD (score, lives, extra)
      ctx.fillStyle = "#000";
      ctx.font = "18px sans-serif";
      ctx.fillText("Score: " + score, 10, 20);
      ctx.fillText("Lives: " + lives + "  Extra: " + extraLives, VIRTUAL_WIDTH - 180, 20);
    }

    // Convert CSS‐stretched pointer coords into 480×640 “virtual” coords
    function getVirtualPointer(e) {
      const rect = canvas.getBoundingClientRect();
      let cssX, cssY;
      if (e.touches && e.touches[0]) {
        cssX = e.touches[0].clientX - rect.left;
        cssY = e.touches[0].clientY - rect.top;
      } else {
        cssX = e.clientX - rect.left;
        cssY = e.clientY - rect.top;
      }
      return {
        x: cssX * (VIRTUAL_WIDTH / rect.width),
        y: cssY * (VIRTUAL_HEIGHT / rect.height)
      };
    }

    // ===== Input Handlers =====

    // pointerdown: place portals or begin rotating Portal B
    canvas.addEventListener("pointerdown", e => {
      if (gameState !== "playing") return;
      const { x, y } = getVirtualPointer(e);

      if (portalPlacementActive) {
        placePortalAnytime(x, y);
        return;
      }
      if (
        portalB &&
        x >= portalB.x && x <= portalB.x + portalB.width &&
        y >= portalB.y && y <= portalB.y + portalB.height
      ) {
        isRotatingB = true;
        const cx = portalB.x + portalB.width / 2;
        const cy = portalB.y + portalB.height / 2;
        portalB.exitAngle = Math.atan2(y - cy, x - cx);
        return;
      }
      // Else do nothing here; firing on pointerup
    });

    // pointermove: rotate Portal B or aim cannon/paddle
    document.getElementById("canvasContainer").addEventListener("pointermove", e => {
      if (gameState !== "playing") return;
      const { x, y } = getVirtualPointer(e);

      if (isRotatingB && portalB) {
        const cx = portalB.x + portalB.width / 2;
        const cy = portalB.y + portalB.height / 2;
        portalB.exitAngle = Math.atan2(y - cy, x - cx);
      } else {
        cannon.aim(x);
        paddle.x = x - paddle.width / 2;
      }
    });

    // pointerup: stop rotating or fire exactly one ball
    canvas.addEventListener("pointerup", e => {
      if (gameState !== "playing") return;
      const { x, y } = getVirtualPointer(e);

      if (isRotatingB) {
        isRotatingB = false;
        return;
      }
      if (skipNextFire) {
        skipNextFire = false;
        return;
      }
      if (portalPlacementActive) {
        return;
      }

      // Check if tap/click was on a brick
      let insideBrick = false;
      for (const b of bricks) {
        if (
          x >= b.x && x <= b.x + b.width &&
          y >= b.y && y <= b.y + b.height
        ) {
          insideBrick = true;
          break;
        }
      }
      // Check if tap was inside Portal B
      let insideB = false;
      if (
        portalB &&
        x >= portalB.x && x <= portalB.x + portalB.width &&
        y >= portalB.y && y <= portalB.y + portalB.height
      ) {
        insideB = true;
      }

      if (allowFiring && !insideBrick && !insideB && cannon.visible) {
        fireBall();
      }
    });

    // “Place Portals” button
    const placePortalsBtn = document.getElementById("placePortalsBtn");
    placePortalsBtn.addEventListener("click", () => {
      if (portalPlacementActive) return;
      portalPlacementActive = true;
      nextPortalType = "A";
      placePortalsBtn.textContent = "Place Portal A";
    });

    // “Restart” button on Game Over overlay
    document.getElementById("restartBtn").addEventListener("click", () => {
      initGame();
    });

    // ===== Start the game =====
    initGame();
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
