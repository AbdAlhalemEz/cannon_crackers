<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Portal Breaker ‚Äì Fade‚ÄêReady Portals</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    /* ===== Full-Screen Setup ===== */
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      background: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none; /* Prevent mobile scroll on canvas touches */
    }

    /* ===== ‚ÄúPlace Portals‚Äù Button ===== */
    #placePortalsBtn {
      margin: 8px 0;
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      background: #3498db;
      color: white;
      border-radius: 4px;
      transition: transform 0.1s;
      z-index: 10;
    }
    #placePortalsBtn:hover { transform: scale(1.05); }
    #placePortalsBtn:active { transform: scale(1.0); }

    /* ===== Canvas Container ===== */
    #canvasContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    #gameCanvas {
      max-width: 100%;
      max-height: 100%;
      background: #f0f0f0;
      image-rendering: pixelated;
    }

    /* ===== Overlay (Game Over) ===== */
    .overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    .overlay.hidden { display: none; }
    .overlay h2, .overlay p {
      color: white;
      margin-bottom: 20px;
      text-align: center;
    }
    .overlay button {
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      border: none;
      background: #e67e22;
      color: white;
      border-radius: 5px;
      transition: transform 0.1s;
    }
    .overlay button:hover { transform: scale(1.05); }
    .overlay button:active { transform: scale(1.0); }
  </style>
</head>
<body>
  <!-- ‚ÄúPlace Portals‚Äù Button -->
  <button id="placePortalsBtn">Place Portals</button>

  <!-- Canvas Container with 480√ó640 Canvas inside -->
  <div id="canvasContainer">
    <canvas id="gameCanvas" width="480" height="640"></canvas>
  </div>

  <!-- Game Over Overlay -->
  <div id="gameOverScreen" class="overlay hidden">
    <h2 id="gameOverText">Game Over</h2>
    <p id="finalScore">Score: 0</p>
    <button id="restartBtn">Restart</button>
  </div>

  <script>
    // ============================
    // Portal Breaker ‚Äì Fade‚ÄêReady Portals
    // ============================
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const VIRTUAL_WIDTH = 480;
    const VIRTUAL_HEIGHT = 640;

    // ======= Game State =======
    let gameState = "playing";   // "playing" or "gameover"
    let lives = 1;
    let extraLives = 0;
    let score = 0;

    let reverseActive = false;
    let reverseEndTime = 0;  // timestamp when the reverse effect ends

    let bricks = [];
    let portalA = null;
    let portalB = null;
    let allowFiring = false;

    let cannon = null;
    let paddle = null;
    let ball = null;   // Will be a Ball instance once fired

    let portalPlacementActive = false;
    let nextPortalType = "A";  // "A" first, then "B"
    let skipNextFire = false;  // skip one tap right after placing a portal

    // Drag/Rotate state for portals:
    let draggingPortal = null;      // "A" or "B" or null
    let needToRotateB = false;      // true when exit angle must be set/finalized
    let justPlacedB = false;        // ignore the very next pointerup after placement

    const PORTAL_COOLDOWN = 10000;   // 10 seconds in ms
    let lastTeleportTime = 0;        // timestamp when the ball last teleported

    const BRICK_WIDTH = 60;
    const BRICK_HEIGHT = 20;
    const BRICK_MARGIN = 5;

    // ======= Helper for Rounded Rectangles =======
    function drawRoundedRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    // ======= Classes =======

    // 1) Ball
    class Ball {
      constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 5;
        this.active = true;
        this.isStuck = false;
        this.justTeleported = false;
      }

      update(delta) {
        if (!this.active && !this.isStuck) return;
        if (this.isStuck) return;

        // Move
        this.x += this.vx * delta;
        this.y += this.vy * delta;

        // 1) Check Portal A ‚Üí teleport
        if (
          portalA !== null &&
          portalB !== null &&
          !this.justTeleported &&
          portalA.collidesWith(this)
        ) {
          this.teleportToPortalB();
          lastTeleportTime = Date.now();
          return; // skip rest this frame
        }

        // 2) Wall collisions
        if (this.x - this.radius <= 0 || this.x + this.radius >= VIRTUAL_WIDTH) {
          this.vx *= -1;
        }
        if (this.y - this.radius <= 0) {
          this.vy *= -1;
        }

        // 3) Bottom/Paddle
        if (this.y + this.radius >= VIRTUAL_HEIGHT) {
          // If it hits the paddle, bounce as before:
          if (
            paddle &&
            this.x >= paddle.x &&
            this.x <= paddle.x + paddle.width
          ) {
            const paddleCenter = paddle.x + paddle.width / 2;
            const relativeHit = (this.x - paddleCenter) / (paddle.width / 2);
            const clamped = Math.max(-1, Math.min(1, relativeHit));
            const maxHoriz = 300;
            // Use reverseActive to flip controls
            const horiz = reverseActive ? -clamped : clamped;
            this.vx = horiz * maxHoriz;
            this.vy = -Math.abs(this.vy);
            this.y = VIRTUAL_HEIGHT - this.radius - paddle.height;
          } 
          // Otherwise, it‚Äôs a ‚Äúlost ball‚Äù event:
          else {
            this.active = false;

            // Decrement extraLives first, if any:
            if (extraLives > 0) {
              extraLives--;
            } else {
              // No extra lives ‚Üí decrement main lives:
              lives--;
            }

            // Check if we still have any life left:
            if (lives > 0 || extraLives > 0) {
              // Respawn a fresh cannon (makes it visible and ready to fire).
              respawnCannon();
            } else {
              // No lives left ‚Üí end the game:
              endGame(false);
            }
          }
        }

        // 4) Brick collisions
        for (const brick of bricks) {
          if (
            (brick.isExtra    && !brick.collected) ||
            (brick.isCursed   && !brick.collected) ||
            (brick.isSpeedUp  && !brick.collected) ||
            (brick.isSlowDown && !brick.collected) ||
            (brick.isSticky   && !brick.collected) ||
            (brick.isTeleport && !brick.collected) ||
            (brick.isInvisible && brick.hp > 0) ||
            (brick.isBomb     && !brick.collected) ||
            (brick.isDouble   && !brick.collected) ||
            (!brick.isExtra && !brick.isCursed && !brick.isSpeedUp &&
             !brick.isSlowDown && !brick.isSticky && !brick.isTeleport &&
             !brick.isInvisible && !brick.isBomb && !brick.isDouble && brick.hp > 0)
          ) {
            if (brick.collidesWith(this)) {
              // EXTRA-LIFE (‚òÖ)
              if (brick.isExtra && !brick.collected) {
                extraLives++;
                brick.collected = true;
                score += 200;
              }
              // CURSED (!) ‚Üí activate reverse
              else if (brick.isCursed && !brick.collected) {
                brick.collected = true;
                score += 150;
                reverseActive = true;
                reverseEndTime = Date.now() + 5000; // 5 seconds
              }
              // SPEED-UP (‚ö°)
              else if (brick.isSpeedUp && !brick.collected) {
                brick.collected = true;
                score += 150;
                this.vx *= 2;
                this.vy *= 2;
                setTimeout(() => {
                  if (this && this.active && !this.isStuck) {
                    this.vx /= 2;
                    this.vy /= 2;
                  }
                }, 4000);
              }
              // SLOW-DOWN (üê¢)
              else if (brick.isSlowDown && !brick.collected) {
                brick.collected = true;
                score += 150;
                this.vx /= 2;
                this.vy /= 2;
                setTimeout(() => {
                  if (this && this.active && !this.isStuck) {
                    this.vx *= 2;
                    this.vy *= 2;
                  }
                }, 5000);
              }
              // STICKY (üï≥Ô∏è)
              else if (brick.isSticky && !brick.collected) {
                brick.collected = true;
                score += 120;
                this.isStuck = true;
                const stuckX = this.x, stuckY = this.y;
                setTimeout(() => {
                  if (gameState === "playing" && this.isStuck) {
                    const dir = (Math.random() < 0.5 ? -1 : +1);
                    const baseSpeed = 200;
                    this.x = stuckX;
                    this.y = stuckY;
                    this.vx = dir * baseSpeed;
                    this.vy = -baseSpeed;
                    this.isStuck = false;
                  }
                }, 1000);
              }
              // TELEPORT (üîÄ)
              else if (brick.isTeleport && !brick.collected) {
                brick.collected = true;
                score += 120;
                let valid = false, newX, newY;
                while (!valid) {
                  newX = Math.random() * (VIRTUAL_WIDTH - 20) + 10;
                  newY = Math.random() * (VIRTUAL_HEIGHT / 2) + 10;
                  valid = true;
                  for (const b2 of bricks) {
                    if (
                      !b2.collected &&
                      b2.collidesWith({ x: newX, y: newY, radius: 10 })
                    ) {
                      valid = false;
                      break;
                    }
                  }
                  if (portalA && valid && portalA.collidesWith({ x: newX, y: newY, radius: 10 })) valid = false;
                  if (portalB && valid && portalB.collidesWith({ x: newX, y: newY, radius: 10 })) valid = false;
                }
                this.x = newX;
                this.y = newY;
              }
              // INVISIBLE (2-step)
              else if (brick.isInvisible && brick.hp > 0) {
                if (!brick.hasBeenHitOnce) {
                  brick.hasBeenHitOnce = true;
                  brick.hp = 1;
                } else {
                  brick.hp = 0;
                  score += 100;
                }
              }
              // BOMB (üí£) ‚Üí clears neighbors
              else if (brick.isBomb && !brick.collected) {
                brick.collected = true;
                score += 250;
                // Remove any nearby bricks (within one brick width/height)
                const neighbors = bricks.filter(b2 => {
                  if (b2 === brick) return false;
                  const dx = Math.abs((b2.x + b2.width/2) - (brick.x + brick.width/2));
                  const dy = Math.abs((b2.y + b2.height/2) - (brick.y + brick.height/2));
                  return dx <= BRICK_WIDTH + BRICK_MARGIN && dy <= BRICK_HEIGHT + BRICK_MARGIN;
                });
                for (const nb of neighbors) {
                  nb.hp = 0;
                  if (!nb.collected && !nb.isExtra && !nb.isCursed && !nb.isSpeedUp &&
                      !nb.isSlowDown && !nb.isSticky && !nb.isTeleport && !nb.isInvisible &&
                      !nb.isBomb && !nb.isDouble) {
                    score += 100 * nb.initialHP;
                  }
                  nb.collected = true;
                }
              }
              // DOUBLE (‚ú¶) ‚Üí big point bonus
              else if (brick.isDouble && !brick.collected) {
                brick.collected = true;
                score += 350;
              }
              // NORMAL (red)
              else if (
                !brick.isExtra &&
                !brick.isCursed &&
                !brick.isSpeedUp &&
                !brick.isSlowDown &&
                !brick.isSticky &&
                !brick.isTeleport &&
                !brick.isInvisible &&
                !brick.isBomb &&
                !brick.isDouble
              ) {
                brick.onHit();
                score += 100 * brick.initialHP;
              }

              if (!this.isStuck) this.reflect(brick, delta);
            }
          }
        }

        // Prune bricks
        bricks = bricks.filter(b => {
          if (b.isExtra || b.isCursed || b.isSpeedUp ||
              b.isSlowDown || b.isSticky || b.isTeleport ||
              b.isBomb || b.isDouble) {
            return !b.collected;
          }
          if (b.isInvisible) return b.hp > 0;
          return b.hp > 0;
        });

        // Win check
        const normalLeft = bricks.filter(b =>
          !b.isExtra && !b.isCursed && !b.isSpeedUp &&
          !b.isSlowDown && !b.isSticky && !b.isTeleport &&
          !b.isInvisible && !b.isBomb && !b.isDouble
        ).length;
        if (normalLeft === 0) {
          endGame(true);
        }
      }

      reflect(brick, delta) {
        const prevX = this.x - this.vx * delta;
        const prevY = this.y - this.vy * delta;
        if (
          prevY + this.radius <= brick.y ||
          prevY - this.radius >= brick.y + BRICK_HEIGHT
        ) {
          this.vy *= -1;
        } else {
          this.vx *= -1;
        }
      }

      teleportToPortalB() {
        const angle = portalB.exitAngle;
        const speedBoost = 150;
        const offset = this.radius + 2;
        const cx = portalB.x + portalB.width / 2;
        const cy = portalB.y + portalB.height / 2;
        this.x = cx + Math.cos(angle) * offset;
        this.y = cy + Math.sin(angle) * offset;
        const baseSpeed = Math.hypot(this.vx, this.vy) + speedBoost;
        this.vx = Math.cos(angle) * baseSpeed;
        this.vy = Math.sin(angle) * baseSpeed;
        this.justTeleported = true;
        setTimeout(() => { this.justTeleported = false; }, 150);
      }

      draw(ctx) {
        if (!this.active && !this.isStuck) return;
        ctx.beginPath();
        ctx.fillStyle = "#000";
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // 2) Paddle
    class Paddle {
      constructor() {
        this.width = 100;
        this.height = 10;
        this.x = (VIRTUAL_WIDTH - this.width) / 2;
        this.y = VIRTUAL_HEIGHT - this.height;
      }
      draw(ctx) {
        ctx.fillStyle = "#8e44ad";
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    // 3) Brick
    class Brick {
      constructor(x, y, type = "normal") {
        this.x = x;
        this.y = y;
        this.isExtra    = (type === "extra");
        this.isCursed   = (type === "cursed");
        this.isSpeedUp  = (type === "speedup");
        this.isSlowDown = (type === "slowdown");
        this.isSticky   = (type === "sticky");
        this.isTeleport = (type === "teleport");
        this.isInvisible= (type === "invisible");
        this.isBomb     = (type === "bomb");
        this.isDouble   = (type === "double");
        this.hasBeenHitOnce = false;

        // Invisible needs 2 hits
        if (this.isInvisible) {
          this.initialHP = 2;
        } 
        // Special single-hit types:
        else if (
          this.isExtra || this.isCursed || this.isSpeedUp ||
          this.isSlowDown || this.isSticky || this.isTeleport ||
          this.isBomb || this.isDouble
        ) {
          this.initialHP = 1;
        } 
        // Otherwise a normal brick gets random HP 1‚Äì10:
        else {
          this.initialHP = Math.floor(Math.random() * 10) + 1;
        }

        this.hp = this.initialHP;
        this.width = BRICK_WIDTH;
        this.height = BRICK_HEIGHT;
        this.collected = false;
      }

      collidesWith(ball) {
        const distX = Math.abs(ball.x - (this.x + this.width / 2));
        const distY = Math.abs(ball.y - (this.y + this.height / 2));
        return !(
          distX > this.width / 2 + ball.radius ||
          distY > this.height / 2 + ball.radius
        );
      }

      onHit() {
        if (
          !this.isExtra && !this.isCursed && !this.isSpeedUp &&
          !this.isSlowDown && !this.isSticky && !this.isTeleport &&
          !this.isInvisible && !this.isBomb && !this.isDouble
        ) {
          this.hp--;
        }
      }

      draw(ctx) {
        ctx.lineWidth = 1;
        if (this.isCursed) {
          ctx.fillStyle = "#8e44ad";    // purple
          ctx.strokeStyle = "#000";
          drawRoundedRect(ctx, this.x, this.y, this.width, this.height, 4);
          ctx.fillStyle = "#fff";
          ctx.font = "20px sans-serif";
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          ctx.fillText("!", this.x + this.width/2, this.y + this.height/2);
        }
        else if (this.isSpeedUp) {
          ctx.fillStyle = "#f1c40f";    // gold
          ctx.strokeStyle = "#000";
          drawRoundedRect(ctx, this.x, this.y, this.width, this.height, 4);
          ctx.fillStyle = "#000";
          ctx.font = "20px sans-serif";
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          ctx.fillText("‚ö°", this.x + this.width/2, this.y + this.height/2);
        }
        else if (this.isSlowDown) {
          ctx.fillStyle = "#3498db";    // blue
          ctx.strokeStyle = "#000";
          drawRoundedRect(ctx, this.x, this.y, this.width, this.height, 4);
          ctx.fillStyle = "#fff";
          ctx.font = "20px sans-serif";
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          ctx.fillText("üê¢", this.x + this.width/2, this.y + this.height/2);
        }
        else if (this.isSticky) {
          ctx.fillStyle = "#27ae60";    // green
          ctx.strokeStyle = "#000";
          drawRoundedRect(ctx, this.x, this.y, this.width, this.height, 4);
          ctx.fillStyle = "#fff";
          ctx.font = "20px sans-serif";
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          ctx.fillText("üï≥Ô∏è", this.x + this.width/2, this.y + this.height/2);
        }
        else if (this.isTeleport) {
          ctx.fillStyle = "#1abc9c";    // teal
          ctx.strokeStyle = "#000";
          drawRoundedRect(ctx, this.x, this.y, this.width, this.height, 4);
          ctx.fillStyle = "#000";
          ctx.font = "20px sans-serif";
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          ctx.fillText("üîÄ", this.x + this.width/2, this.y + this.height/2);
        }
        else if (this.isInvisible) {
          if (!this.hasBeenHitOnce) {
            ctx.fillStyle = "#bdc3c7";  // light gray
            ctx.strokeStyle = "#000";
            drawRoundedRect(ctx, this.x, this.y, this.width, this.height, 4);
          }
        }
        else if (this.isExtra) {
          ctx.fillStyle = "#2ecc71";    // bright green
          ctx.strokeStyle = "#000";
          drawRoundedRect(ctx, this.x, this.y, this.width, this.height, 4);
          ctx.fillStyle = "#fff";
          ctx.font = "20px sans-serif";
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          ctx.fillText("‚òÖ", this.x + this.width/2, this.y + this.height/2);
        }
        else if (this.isBomb) {
          ctx.fillStyle = "#e74c3c";    // red
          ctx.strokeStyle = "#000";
          drawRoundedRect(ctx, this.x, this.y, this.width, this.height, 4);
          ctx.fillStyle = "#000";
          ctx.font = "20px sans-serif";
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          ctx.fillText("üí£", this.x + this.width/2, this.y + this.height/2);
        }
        else if (this.isDouble) {
          ctx.fillStyle = "#f39c12";    // orange
          ctx.strokeStyle = "#000";
          drawRoundedRect(ctx, this.x, this.y, this.width, this.height, 4);
          ctx.fillStyle = "#000";
          ctx.font = "20px sans-serif";
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          ctx.fillText("‚ú¶", this.x + this.width/2, this.y + this.height/2);
        }
        else {
          // Normal brick: red gradient
          const grad = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
          grad.addColorStop(0, "#e74c3c");
          grad.addColorStop(1, "#c0392b");
          ctx.fillStyle = grad;
          ctx.strokeStyle = "#900";
          drawRoundedRect(ctx, this.x, this.y, this.width, this.height, 4);

          ctx.fillStyle = "#fff";
          ctx.font = "16px sans-serif";
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          const text = String(this.hp <= 0 ? 0 : this.hp);
          ctx.fillText(text, this.x + this.width/2, this.y + this.height/2);
        }
      }
    }

    // 4) Portal
    class Portal {
      constructor(x, y, type) {
        this.x = Math.floor(x / 10) * 10;
        this.y = Math.floor(y / 10) * 10;
        this.width = BRICK_WIDTH;
        this.height = BRICK_HEIGHT;
        this.type = type; // "A" or "B"
        this.exitAngle = -Math.PI / 2; // default: straight up
        this.lastMoveTime = Date.now();
      }
      isReady() {
        const sinceMove = Date.now() - this.lastMoveTime;
        const sinceTele = Date.now() - lastTeleportTime;
        return (sinceMove >= PORTAL_COOLDOWN && sinceTele >= PORTAL_COOLDOWN);
      }
      collidesWith(ball) {
        return (
          ball.x >= this.x &&
          ball.x <= this.x + this.width &&
          ball.y >= this.y &&
          ball.y <= this.y + this.height
        );
      }
      draw(ctx) {
        const ready = this.isReady();
        ctx.globalAlpha = ready ? 0.9 : 0.3;
        ctx.fillStyle = (this.type === "A") ? "#0064ff" : "#ff6400";
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.globalAlpha = 1; // reset

        if (this.type === "B") {
          // draw arrow at full opacity
          const cx = this.x + this.width / 2;
          const cy = this.y + this.height / 2;
          const len = this.width / 2 - 4;
          const ax = cx + Math.cos(this.exitAngle) * len;
          const ay = cy + Math.sin(this.exitAngle) * len;

          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(ax, ay);
          ctx.stroke();

          ctx.fillStyle = "#fff";
          const arrowSize = 6;
          const theta = this.exitAngle;
          const back1 = theta + Math.PI - 0.4;
          const back2 = theta + Math.PI + 0.4;

          ctx.beginPath();
          ctx.moveTo(cx + Math.cos(theta) * len, cy + Math.sin(theta) * len);
          ctx.lineTo(
            cx + Math.cos(back1) * arrowSize + Math.cos(theta) * len,
            cy + Math.sin(back1) * arrowSize + Math.sin(theta) * len
          );
          ctx.lineTo(
            cx + Math.cos(back2) * arrowSize + Math.cos(theta) * len,
            cy + Math.sin(back2) * arrowSize + Math.sin(theta) * len
          );
          ctx.closePath();
          ctx.fill();
        }
      }
    }

    // 5) Cannon
    class Cannon {
      constructor() {
        this.x = VIRTUAL_WIDTH / 2;
        this.y = VIRTUAL_HEIGHT - 30;
        this.angle = -Math.PI / 2;
        this.visible = true;
      }
      aim(pointerX) {
        this.angle = Math.atan2(0 - this.y, pointerX - this.x);
        if (this.angle < -Math.PI) this.angle = -Math.PI;
        if (this.angle > 0) this.angle = 0;
      }
      draw(ctx) {
        if (!this.visible) return;
        ctx.fillStyle = "#7f8c8d";
        ctx.fillRect(this.x - 20, this.y, 40, 20);
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = "#34495e";
        ctx.fillRect(0, -5, 40, 10);
        ctx.restore();
        ctx.strokeStyle = "rgba(0,0,0,0.3)";
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        const endX = this.x + Math.cos(this.angle) * 100;
        const endY = this.y + Math.sin(this.angle) * 100;
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // ======= Helper Functions =======

    function placePortalAnytime(x, y) {
      // Reject if overlap any brick
      for (const b of bricks) {
        if (
          x >= b.x && x <= b.x + b.width &&
          y >= b.y && y <= b.y + b.height
        ) {
          return false;
        }
      }
      if (nextPortalType === "A") {
        portalA = new Portal(x - BRICK_WIDTH / 2, y - BRICK_HEIGHT / 2, "A");
        nextPortalType = "B";
        placePortalsBtn.textContent = "Place Portal B";
      } else {
        portalB = new Portal(x - BRICK_WIDTH / 2, y - BRICK_HEIGHT / 2, "B");
        // Now force exit rotation, but ignore this click's pointerup:
        needToRotateB = true;
        justPlacedB = true;
        allowFiring = false;
        portalPlacementActive = false;
        placePortalsBtn.textContent = "Place Portals";
      }
      return true;
    }

    function fireBall() {
      if (portalA === null || portalB === null || needToRotateB) return;
      const speed = 300;
      const vx = Math.cos(cannon.angle) * speed;
      const vy = Math.sin(cannon.angle) * speed;
      const spawnX = cannon.x + Math.cos(cannon.angle) * 40;
      const spawnY = cannon.y + Math.sin(cannon.angle) * 40;
      ball = new Ball(spawnX, spawnY, vx, vy);
      cannon.visible = false;
      allowFiring = false;
    }

    function setupBricks() {
      bricks = [];
      for (let row = 0; row < 3; row++) {
        const y = 40 + row * (BRICK_HEIGHT + BRICK_MARGIN);
        for (let i = 0; i < 7; i++) {
          const x = 40 + i * (BRICK_WIDTH + BRICK_MARGIN);
          let type = "normal";
          const rnd = Math.random();
          if (rnd < 0.05)        type = "cursed";    // 5%
          else if (rnd < 0.10)   type = "extra";     // 5%
          else if (rnd < 0.15)   type = "speedup";   // 5%
          else if (rnd < 0.20)   type = "slowdown";  // 5%
          else if (rnd < 0.25)   type = "sticky";    // 5%
          else if (rnd < 0.30)   type = "teleport";  // 5%
          else if (rnd < 0.35)   type = "invisible"; // 5%
          else if (rnd < 0.40)   type = "bomb";      // 5%
          else if (rnd < 0.45)   type = "double";    // 5%
          bricks.push(new Brick(x, y, type));
        }
      }
      // Ensure at least one of each special type
      const ensureType = t => {
        if (!bricks.some(b => (
            (t==="extra"    && b.isExtra   ) ||
            (t==="cursed"   && b.isCursed  ) ||
            (t==="speedup"  && b.isSpeedUp ) ||
            (t==="slowdown" && b.isSlowDown) ||
            (t==="sticky"   && b.isSticky  ) ||
            (t==="teleport" && b.isTeleport) ||
            (t==="invisible"&& b.isInvisible) ||
            (t==="bomb"     && b.isBomb    ) ||
            (t==="double"   && b.isDouble  )
        ))) {
          const idx = Math.floor(Math.random() * bricks.length);
          const b = bricks[idx];
          // Clear all flags, then set this one
          b.isExtra    = b.isCursed = b.isSpeedUp = b.isSlowDown =
          b.isSticky   = b.isTeleport = b.isInvisible = b.isBomb = b.isDouble = false;
          b.hasBeenHitOnce = false;
          b.collected = false;
          if (t === "extra")    b.isExtra    = true;
          else if (t === "cursed")   b.isCursed   = true;
          else if (t === "speedup")  b.isSpeedUp  = true;
          else if (t === "slowdown") b.isSlowDown = true;
          else if (t === "sticky")   b.isSticky   = true;
          else if (t === "teleport") b.isTeleport = true;
          else if (t === "invisible") {
            b.isInvisible = true;
            b.initialHP = 2;
            b.hp = 2;
          }
          else if (t === "bomb") {
            b.isBomb = true;
            b.initialHP = 1;
            b.hp = 1;
          }
          else if (t === "double") {
            b.isDouble = true;
            b.initialHP = 1;
            b.hp = 1;
          }
        }
      };
      [
        "extra","cursed","speedup","slowdown","sticky","teleport","invisible","bomb","double"
      ].forEach(ensureType);
    }

    function endGame(win) {
      gameState = "gameover";
      canvas.style.pointerEvents = "none";
      document.getElementById("gameOverScreen").classList.remove("hidden");
      document.getElementById("gameOverText").textContent = win ? "You Win!" : "Game Over";
      document.getElementById("finalScore").textContent = "Score: " + score;
    }

    function respawnCannon() {
      cannon.visible = true;
      allowFiring = true;
      ball = null;
    }

    function initGame() {
      lives = 1;
      extraLives = 0;
      score = 0;
      reverseActive = false;
      reverseEndTime = 0;
      portalA = null;
      portalB = null;
      allowFiring = false;
      portalPlacementActive = false;
      nextPortalType = "A";
      skipNextFire = false;
      draggingPortal = null;
      needToRotateB = false;
      justPlacedB = false;
      lastTeleportTime = 0;
      cannon = new Cannon();
      paddle = new Paddle();
      ball = null;
      setupBricks();
      gameState = "playing";
      canvas.style.pointerEvents = "auto";
      document.getElementById("gameOverScreen").classList.add("hidden");
      draw(); // initial draw
    }

    let lastTime = 0;
    function gameLoop(time) {
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      // Handle reverse expiration
      if (reverseActive && Date.now() >= reverseEndTime) {
        reverseActive = false;
      }

      if (gameState === "playing") {
        if (ball) {
          if (ball.active && !ball.isStuck) {
            ball.update(delta);
          } else if (!ball.active && !ball.isStuck) {
            ball = null;
          }
        }
      }

      draw();
      requestAnimationFrame(gameLoop);
    }

    function draw() {
      ctx.clearRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);

      // Draw bricks
      for (const b of bricks) b.draw(ctx);

      // Draw cannon & paddle & ball
      if (cannon) cannon.draw(ctx);
      if (paddle) paddle.draw(ctx);
      if (ball) ball.draw(ctx);

      // DRAW PORTALS (fade while on cooldown)
      if (portalA) portalA.draw(ctx);
      if (portalB) portalB.draw(ctx);

      // Draw top panel (score/lives + reverse timer only)
      ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
      ctx.fillRect(0, 0, VIRTUAL_WIDTH, 60);

      ctx.fillStyle = "#fff";
      ctx.font = "18px sans-serif";
      ctx.fillText("Score: " + score, 10, 24);
      ctx.fillText("Lives: " + lives + "  Extra: " + extraLives, VIRTUAL_WIDTH - 200, 24);

      // Reverse timer
      const now = Date.now();
      if (reverseActive) {
        let rem = Math.ceil((reverseEndTime - now) / 1000);
        if (rem < 0) rem = 0;
        ctx.fillStyle = "#e74c3c";
        ctx.font = "16px sans-serif";
        ctx.fillText("Reverse: " + rem + "s", 10, 48);
      }

      // If rotating B, show instructions at bottom
      if (needToRotateB) {
        ctx.fillStyle = "#fff";
        ctx.font = "14px sans-serif";
        ctx.fillText("Move cursor to set exit, then click to confirm", 20, VIRTUAL_HEIGHT - 20);
      }
    }

    // Convert CSS-stretched pointer coords into 480√ó640 ‚Äúvirtual‚Äù coords
    function getVirtualPointer(e) {
      const rect = canvas.getBoundingClientRect();
      let cssX, cssY;
      if (e.touches && e.touches[0]) {
        cssX = e.touches[0].clientX - rect.left;
        cssY = e.touches[0].clientY - rect.top;
      } else {
        cssX = e.clientX - rect.left;
        cssY = e.clientY - rect.top;
      }
      return {
        x: cssX * (VIRTUAL_WIDTH / rect.width),
        y: cssY * (VIRTUAL_HEIGHT / rect.height)
      };
    }

    // Check if a portal may be moved/rotated now:
    function canUsePortal(portal) {
      if (!portal) return false;
      const sinceMove = Date.now() - portal.lastMoveTime;
      const sinceTele = Date.now() - lastTeleportTime;
      return (sinceMove >= PORTAL_COOLDOWN && sinceTele >= PORTAL_COOLDOWN);
    }

    // ===== Input Handlers =====

    // pointerdown: place portals, or begin drag
    canvas.addEventListener("pointerdown", e => {
      if (gameState !== "playing") return;
      const { x, y } = getVirtualPointer(e);

      // 1) Place portals mode
      if (portalPlacementActive) {
        placePortalAnytime(x, y);
        return;
      }

      // 2) If Portal B exists, on cooldown, and not waiting to rotate:
      if (
        portalB &&
        canUsePortal(portalB) &&
        !needToRotateB &&
        x >= portalB.x && x <= portalB.x + portalB.width &&
        y >= portalB.y && y <= portalB.y + portalB.height
      ) {
        // Start dragging Portal B
        draggingPortal = "B";
        skipNextFire = true;
        return;
      }

      // 3) If Portal A exists, on cooldown:
      if (
        portalA &&
        canUsePortal(portalA) &&
        x >= portalA.x && x <= portalA.x + portalA.width &&
        y >= portalA.y && y <= portalA.y + portalA.height
      ) {
        draggingPortal = "A";
        skipNextFire = true;
        return;
      }

      // Otherwise, do nothing; firing occurs on pointerup.
    });

    // pointermove: if dragging portals or if waiting to rotate B, update angle
    document.getElementById("canvasContainer").addEventListener("pointermove", e => {
      if (gameState !== "playing") return;
      const { x, y } = getVirtualPointer(e);

      // If rotating Portal B:
      if (needToRotateB && portalB) {
        const cx = portalB.x + portalB.width / 2;
        const cy = portalB.y + portalB.height / 2;
        portalB.exitAngle = Math.atan2(y - cy, x - cx);
        return;
      }
      // If dragging Portal B:
      if (draggingPortal === "B" && portalB) {
        portalB.x = x - portalB.width / 2;
        portalB.y = y - portalB.height / 2;
        portalB.x = Math.round(portalB.x / 10) * 10;
        portalB.y = Math.round(portalB.y / 10) * 10;
        return;
      }
      // If dragging Portal A:
      if (draggingPortal === "A" && portalA) {
        portalA.x = x - portalA.width / 2;
        portalA.y = y - portalA.height / 2;
        portalA.x = Math.round(portalA.x / 10) * 10;
        portalA.y = Math.round(portalA.y / 10) * 10;
        return;
      }
      // Otherwise: aim cannon/paddle using reverseActive
      const effectiveX = reverseActive ? (VIRTUAL_WIDTH - x) : x;
      cannon.aim(effectiveX);
      paddle.x = effectiveX - paddle.width / 2;
    });

    // pointerup: finalize drag, finalize rotation (unless just placed), or fire
    canvas.addEventListener("pointerup", e => {
      if (gameState !== "playing") return;
      const { x, y } = getVirtualPointer(e);

      // 1) If we were rotating Portal B:
      if (needToRotateB && portalB) {
        // If it was just placed, ignore this pointerup:
        if (justPlacedB) {
          justPlacedB = false;
          return;
        }
        // Otherwise finalize rotation:
        needToRotateB = false;
        portalB.lastMoveTime = Date.now();
        allowFiring = true;
        skipNextFire = true;
        return;
      }
      // 2) If we were dragging Portal B:
      if (draggingPortal === "B" && portalB) {
        draggingPortal = null;
        portalB.lastMoveTime = Date.now();
        // Immediately need to rotate the exit:
        needToRotateB = true;
        allowFiring = false;
        skipNextFire = true;
        return;
      }
      // 3) If we were dragging Portal A:
      if (draggingPortal === "A" && portalA) {
        portalA.lastMoveTime = Date.now();
        draggingPortal = null;
        return;
      }

      // 4) If skipNextFire is set, consume it and do nothing
      if (skipNextFire) {
        skipNextFire = false;
        return;
      }
      if (portalPlacementActive) {
        return;
      }

      // Check if tap was inside a brick
      let insideBrick = false;
      for (const b of bricks) {
        if (
          x >= b.x && x <= b.x + b.width &&
          y >= b.y && y <= b.y + b.height
        ) {
          insideBrick = true;
          break;
        }
      }
      // Check if tap was inside Portal B
      let insideB = false;
      if (
        portalB &&
        x >= portalB.x && x <= portalB.x + portalB.width &&
        y >= portalB.y && y <= portalB.y + portalB.height
      ) {
        insideB = true;
      }

      // Fire if allowed, not clicking bricks or Portal B, and cannon visible
      if (allowFiring && !insideBrick && !insideB && cannon.visible) {
        fireBall();
      }
    });

    // ‚ÄúPlace Portals‚Äù button
    const placePortalsBtn = document.getElementById("placePortalsBtn");
    placePortalsBtn.addEventListener("click", () => {
      if (portalPlacementActive) return;
      portalPlacementActive = true;
      nextPortalType = "A";
      placePortalsBtn.textContent = "Place Portal A";
    });

    // ‚ÄúRestart‚Äù button on Game Over overlay
    document.getElementById("restartBtn").addEventListener("click", () => {
      initGame();
    });

    // ===== Start the game =====
    initGame();
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
