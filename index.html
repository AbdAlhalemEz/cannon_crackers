<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Portal Breaker – Full‐Screen Responsive & Corrected Firing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- ===== Embedded CSS ===== -->
  <style>
    /* ==== Make the page fill the viewport ==== */
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      background: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none; /* Prevent mobile scrolling when touching canvas */
    }

    /* ==== Place‐Portals Button ==== */
    #placePortalsBtn {
      margin: 8px 0;
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      background: #3498db;
      color: #fff;
      border-radius: 4px;
      transition: transform 0.1s;
      z-index: 10;
    }
    #placePortalsBtn:hover {
      transform: scale(1.05);
    }
    #placePortalsBtn:active {
      transform: scale(1.0);
    }

    /* ==== Canvas Styling: fill entire viewport ==== */
    #canvasContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #000;
      overflow: hidden;
    }
    #gameCanvas {
      /* Stretch to exactly fill viewport, even if aspect differs */
      width: 100vw;
      height: 100vh;
      background: #f0f0f0;
      image-rendering: pixelated; /* optional for crisp look */
    }

    /* ==== Overlays (Game Over, How‐to, etc.) ==== */
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    .overlay.hidden {
      display: none;
    }
    .overlay h1,
    .overlay h2 {
      margin-bottom: 20px;
      font-size: 32px;
      color: #fff;
    }
    .overlay p {
      margin: 10px;
      font-size: 18px;
      text-align: center;
      max-width: 80%;
      color: #fff;
    }
    .overlay button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      border: none;
      background: #e67e22;
      color: #fff;
      border-radius: 5px;
      transition: transform 0.1s;
    }
    .overlay button:hover {
      transform: scale(1.05);
    }
    .overlay button:active {
      transform: scale(1.0);
    }
  </style>
</head>
<body>
  <!-- Place‐Portals Button -->
  <button id="placePortalsBtn">Place Portals</button>

  <!-- Container to center and fill the canvas -->
  <div id="canvasContainer">
    <canvas id="gameCanvas" width="480" height="640"></canvas>
  </div>

  <!-- Game Over / Win Overlay -->
  <div id="gameOverScreen" class="overlay hidden">
    <h2 id="gameOverText">Game Over</h2>
    <p id="finalScore">Score: 0</p>
    <button id="restartBtn">Restart</button>
  </div>

  <!-- How to Play Overlay (optional) -->
  <div id="howToScreen" class="overlay hidden">
    <h2>How to Play</h2>
    <p>
      1. Tap “Place Portals” any time to begin placing.<br />
      2. Tap twice off‐brick to place Portal A (blue) then Portal B (orange).<br />
      3. Tap‐and‐drag inside Portal B to rotate its exit arrow; release to lock.<br />
      4. To fire, tap anywhere <strong>outside</strong> portal placement/rotation.<br />
      5. Break all bricks to win; missing the paddle 3 times → lose.
    </p>
    <button class="backBtn">Back</button>
  </div>

  <!-- Settings Overlay (audio disabled) -->
  <div id="settingsScreen" class="overlay hidden">
    <h2>Settings</h2>
    <p>Audio is currently disabled.</p>
    <button class="backBtn">Back</button>
  </div>

  <!-- Credits Overlay -->
  <div id="creditsScreen" class="overlay hidden">
    <h2>Credits</h2>
    <p>Developed by: Your Name</p>
    <button class="backBtn">Back</button>
  </div>

  <!-- ======= Embedded JavaScript ======= -->
  <script>
    // =========================
    // Portal Breaker – Full‐Screen Responsive & Corrected Firing
    // =========================

    // ======= 1. Canvas & Scaling Setup =======
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    // Virtual game resolution:
    const VIRTUAL_WIDTH = 480;
    const VIRTUAL_HEIGHT = 640;

    // ======= 2. Game State =======
    let gameState = "playing";     // “playing” or “gameover”
    let score = 0;
    let lives = 3;

    let bricks = [];
    let portalA = null;   // entry portal
    let portalB = null;   // exit portal
    let allowFiring = false;

    let cannon, paddle, balls = [];

    // Brick dimensions & spacing (in virtual coords)
    const BRICK_WIDTH = 60;
    const BRICK_HEIGHT = 20;
    const BRICK_MARGIN = 5;

    // Portal‐placement anywhere state
    let portalPlacementActive = false;
    let nextPortalType = "A"; // place A first, then B

    // Rotating Portal B
    let isRotatingB = false;

    // Skip firing flag (to prevent immediate fire after placing portals)
    let skipNextFire = false;

    // ======= 3. Game Object Classes =======

    // 3.1 Ball
    class Ball {
      constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 5;
        this.active = true;
        this.justTeleported = false;
      }
      update(delta) {
        if (!this.active) return;
        // Move
        this.x += this.vx * delta;
        this.y += this.vy * delta;

        // Wall collisions (left/right)
        if (this.x - this.radius <= 0 || this.x + this.radius >= VIRTUAL_WIDTH) {
          this.vx *= -1;
        }
        // Ceiling collision
        if (this.y - this.radius <= 0) {
          this.vy *= -1;
        }

        // Paddle collision (bottom)
        if (this.y + this.radius >= VIRTUAL_HEIGHT) {
          if (
            paddle &&
            this.x >= paddle.x &&
            this.x <= paddle.x + paddle.width
          ) {
            this.vy *= -1;
            this.y = VIRTUAL_HEIGHT - this.radius - paddle.height;
          } else {
            this.active = false;
            lives--;
            if (lives <= 0) {
              endGame(false);
            }
          }
        }

        // Brick collisions
        bricks.forEach((brick) => {
          if (brick.hp > 0 && brick.collidesWith(this)) {
            brick.onHit();
            const prevX = this.x - this.vx * delta;
            const prevY = this.y - this.vy * delta;
            if (
              prevY + this.radius <= brick.y ||
              prevY - this.radius >= brick.y + BRICK_HEIGHT
            ) {
              this.vy *= -1;
            } else {
              this.vx *= -1;
            }
            score += 100 * brick.initialHP;
          }
        });
        bricks = bricks.filter((b) => b.hp > 0);

        // Portal A collision (one‐way)
        if (
          portalA &&
          portalB &&
          !this.justTeleported &&
          portalA.collidesWith(this)
        ) {
          this.teleportToPortalB();
        }

        // Win condition
        if (bricks.length === 0) {
          endGame(true);
        }
      }
      teleportToPortalB() {
        const angle = portalB.exitAngle;
        const speedBoost = 150;
        const offset = this.radius + 2;
        const cx = portalB.x + portalB.width / 2;
        const cy = portalB.y + portalB.height / 2;

        this.x = cx + Math.cos(angle) * offset;
        this.y = cy + Math.sin(angle) * offset;

        const baseSpeed = Math.hypot(this.vx, this.vy) + speedBoost;
        this.vx = Math.cos(angle) * baseSpeed;
        this.vy = Math.sin(angle) * baseSpeed;

        this.justTeleported = true;
        setTimeout(() => {
          this.justTeleported = false;
        }, 150);
      }
      draw(ctx) {
        if (!this.active) return;
        ctx.beginPath();
        ctx.fillStyle = "#000";
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // 3.2 Paddle
    class Paddle {
      constructor() {
        this.width = 100;
        this.height = 10;
        this.x = (VIRTUAL_WIDTH - this.width) / 2;
        this.y = VIRTUAL_HEIGHT - this.height;
      }
      draw(ctx) {
        ctx.fillStyle = "#8e44ad";
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    // 3.3 Brick (random HP 1–10)
    class Brick {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.initialHP = Math.floor(Math.random() * 10) + 1; 
        this.hp = this.initialHP;
        this.width = BRICK_WIDTH;
        this.height = BRICK_HEIGHT;
      }
      collidesWith(ball) {
        const distX = Math.abs(ball.x - (this.x + this.width / 2));
        const distY = Math.abs(ball.y - (this.y + this.height / 2));
        if (
          distX > this.width / 2 + ball.radius ||
          distY > this.height / 2 + ball.radius
        ) {
          return false;
        }
        return true;
      }
      onHit() {
        this.hp--;
      }
      draw(ctx) {
        // Red fill
        ctx.fillStyle = "#e74c3c";
        ctx.fillRect(this.x, this.y, this.width, this.height);
        // Black border
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1;
        ctx.strokeRect(this.x, this.y, this.width, this.height);
        // HP text
        ctx.fillStyle = "#fff";
        ctx.font = "16px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const text = String(this.hp <= 0 ? 0 : this.hp);
        const cx = this.x + this.width / 2;
        const cy = this.y + this.height / 2;
        ctx.fillText(text, cx, cy);
      }
    }

    // 3.4 Portal
    class Portal {
      constructor(x, y, type) {
        this.x = Math.floor(x / 10) * 10;
        this.y = Math.floor(y / 10) * 10;
        this.width = BRICK_WIDTH;
        this.height = BRICK_HEIGHT;
        this.type = type; // "A" or "B"
        if (type === "B") {
          this.exitAngle = -Math.PI / 2; // default straight up
        } else {
          this.exitAngle = null;
        }
      }
      collidesWith(ball) {
        return (
          ball.x >= this.x &&
          ball.x <= this.x + this.width &&
          ball.y >= this.y &&
          ball.y <= this.y + this.height
        );
      }
      draw(ctx) {
        if (this.type === "A") {
          ctx.fillStyle = "#0064ff"; // blue
        } else {
          ctx.fillStyle = "#ff6400"; // orange
        }
        ctx.globalAlpha = 0.5;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.globalAlpha = 1;
        if (this.type === "B") {
          const cx = this.x + this.width / 2;
          const cy = this.y + this.height / 2;
          const len = this.width / 2 - 4;
          const ax = cx + Math.cos(this.exitAngle) * len;
          const ay = cy + Math.sin(this.exitAngle) * len;
          // Arrow body
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(ax, ay);
          ctx.stroke();
          // Arrowhead
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          const arrowSize = 6;
          const theta = this.exitAngle;
          const back1 = theta + Math.PI - 0.4;
          const back2 = theta + Math.PI + 0.4;
          ctx.moveTo(cx + Math.cos(theta) * len, cy + Math.sin(theta) * len);
          ctx.lineTo(
            cx + Math.cos(back1) * arrowSize + Math.cos(theta) * len,
            cy + Math.sin(back1) * arrowSize + Math.sin(theta) * len
          );
          ctx.lineTo(
            cx + Math.cos(back2) * arrowSize + Math.cos(theta) * len,
            cy + Math.sin(back2) * arrowSize + Math.sin(theta) * len
          );
          ctx.closePath();
          ctx.fill();
        }
      }
    }

    // 3.5 Cannon
    class Cannon {
      constructor() {
        this.x = VIRTUAL_WIDTH / 2;
        this.y = VIRTUAL_HEIGHT - 30;
        this.angle = -Math.PI / 2;
      }
      aim(pointerX) {
        const dx = pointerX - this.x;
        const dy = 0 - this.y;
        this.angle = Math.atan2(dy, dx);
        if (this.angle < -Math.PI) this.angle = -Math.PI;
        if (this.angle > 0) this.angle = 0;
      }
      draw(ctx) {
        ctx.fillStyle = "#7f8c8d";
        ctx.fillRect(this.x - 20, this.y, 40, 20);
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = "#34495e";
        ctx.fillRect(0, -5, 40, 10);
        ctx.restore();
        ctx.strokeStyle = "rgba(0,0,0,0.3)";
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        const endX = this.x + Math.cos(this.angle) * 100;
        const endY = this.y + Math.sin(this.angle) * 100;
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // ======= 4. Helpers =======

    // Place Portal A or B when portalPlacementActive
    function placePortalAnytime(x, y) {
      // Don’t place on a brick
      for (const b of bricks) {
        if (
          x >= b.x &&
          x <= b.x + b.width &&
          y >= b.y &&
          y <= b.y + b.height
        ) {
          return false;
        }
      }
      if (nextPortalType === "A") {
        portalA = new Portal(x - BRICK_WIDTH / 2, y - BRICK_HEIGHT / 2, "A");
        nextPortalType = "B";
        placePortalsBtn.textContent = "Place Portal B";
      } else {
        portalB = new Portal(x - BRICK_WIDTH / 2, y - BRICK_HEIGHT / 2, "B");
        allowFiring = true;
        portalPlacementActive = false;
        placePortalsBtn.textContent = "Place Portals";
      }
      // After placement, skip the next pointerup‐firing
      skipNextFire = true;
      return true;
    }

    // Fire three balls (spread ±0.1 rad)
    function fireBalls() {
      const baseAngle = cannon.angle;
      const speed = 300;
      const spreads = [0, 0.1, -0.1];
      balls = spreads.map((dθ) => {
        const ang = baseAngle + dθ;
        const vx = Math.cos(ang) * speed;
        const vy = Math.sin(ang) * speed;
        const spawnX = cannon.x + Math.cos(baseAngle) * 40;
        const spawnY = cannon.y + Math.sin(baseAngle) * 40;
        return new Ball(spawnX, spawnY, vx, vy);
      });
    }

    // Setup bricks with random HP 1–10
    function setupBricks() {
      bricks = [];
      for (let row = 0; row < 3; row++) {
        const y = 40 + row * (BRICK_HEIGHT + BRICK_MARGIN);
        for (let i = 0; i < 7; i++) {
          const x = 40 + i * (BRICK_WIDTH + BRICK_MARGIN);
          bricks.push(new Brick(x, y));
        }
      }
    }

    // End the game
    function endGame(win) {
      gameState = "gameover";
      canvas.style.pointerEvents = "none"; // disable canvas interaction
      document.getElementById("gameOverScreen").classList.remove("hidden");
      document.getElementById("gameOverText").textContent = win ? "You Win!" : "Game Over";
      document.getElementById("finalScore").textContent = "Score: " + score;
    }

    // ======= 5. Initialization & Main Loop =======

    function initGame() {
      score = 0;
      lives = 3;
      portalA = null;
      portalB = null;
      allowFiring = false;
      portalPlacementActive = false;
      nextPortalType = "A";
      skipNextFire = false;
      placePortalsBtn.textContent = "Place Portals";

      setupBricks();
      cannon = new Cannon();
      paddle = new Paddle();
      balls = [];
      gameState = "playing";

      canvas.style.pointerEvents = "auto";
      document.getElementById("gameOverScreen").classList.add("hidden");
      draw(); // initial draw
    }

    let lastTime = 0;
    function gameLoop(time) {
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      if (gameState === "playing") {
        balls.forEach((b) => b.update(delta));
        balls = balls.filter((b) => b.active);
      }

      draw();
      requestAnimationFrame(gameLoop);
    }

    // Draw everything in virtual coordinates
    function draw() {
      ctx.clearRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);

      // Bricks
      bricks.forEach((b) => b.draw(ctx));
      // Portals
      if (portalA) portalA.draw(ctx);
      if (portalB) portalB.draw(ctx);
      // Cannon & paddle
      cannon.draw(ctx);
      paddle.draw(ctx);
      // Balls
      balls.forEach((b) => b.draw(ctx));
      // HUD
      ctx.fillStyle = "#000";
      ctx.font = "18px sans-serif";
      ctx.fillText("Score: " + score, 10, 20);
      ctx.fillText("Lives: " + lives, VIRTUAL_WIDTH - 80, 20);
    }

    // ======= 6. Input Handling (Pointer Events) =======
    // Convert CSS‐stretched pointer coordinates into virtual 480×640 coords.

    function getVirtualPointer(e) {
      const rect = canvas.getBoundingClientRect();
      let cssX, cssY;
      if (e.touches && e.touches[0]) {
        cssX = e.touches[0].clientX - rect.left;
        cssY = e.touches[0].clientY - rect.top;
      } else {
        cssX = e.clientX - rect.left;
        cssY = e.clientY - rect.top;
      }
      const scaleX = VIRTUAL_WIDTH / rect.width;
      const scaleY = VIRTUAL_HEIGHT / rect.height;
      return {
        x: cssX * scaleX,
        y: cssY * scaleY
      };
    }

    // pointerdown: place portals or start rotating B
    canvas.addEventListener("pointerdown", (e) => {
      if (gameState !== "playing") return;
      const { x, y } = getVirtualPointer(e);

      // If in portal‐placement mode, place A or B
      if (portalPlacementActive) {
        if (placePortalAnytime(x, y)) {
          return;
        }
        return;
      }

      // If click inside Portal B, start rotating
      if (
        portalB &&
        x >= portalB.x &&
        x <= portalB.x + portalB.width &&
        y >= portalB.y &&
        y <= portalB.y + portalB.height
      ) {
        isRotatingB = true;
        setPortalBAngleFromPointer(x, y);
        return;
      }
      // Otherwise do nothing here
    });

    // pointermove: rotate Portal B or aim cannon/paddle
    canvas.addEventListener("pointermove", (e) => {
      if (gameState !== "playing") return;
      const { x, y } = getVirtualPointer(e);

      if (isRotatingB && portalB) {
        setPortalBAngleFromPointer(x, y);
      } else {
        // Aim cannon & move paddle
        cannon.aim(x);
        paddle.x = x - paddle.width / 2;
      }
    });

    // pointerup: stop rotating, skip if just placed portal, or fire balls
    canvas.addEventListener("pointerup", (e) => {
      if (gameState !== "playing") return;
      const { x, y } = getVirtualPointer(e);

      if (isRotatingB) {
        isRotatingB = false;
        return;
      }
      if (skipNextFire) {
        skipNextFire = false;
        return;
      }
      if (portalPlacementActive) {
        return;
      }

      // Fire whenever pointerup happens (since we no longer restrict to bottom region)
      // as long as it wasn’t on a brick or Portal B
      let insideBrick = false;
      for (const b of bricks) {
        if (
          x >= b.x &&
          x <= b.x + b.width &&
          y >= b.y &&
          y <= b.y + b.height
        ) {
          insideBrick = true;
          break;
        }
      }
      let insideB = false;
      if (
        portalB &&
        x >= portalB.x &&
        x <= portalB.x + portalB.width &&
        y >= portalB.y &&
        y <= portalB.y + portalB.height
      ) {
        insideB = true;
      }
      if (allowFiring && !insideBrick && !insideB) {
        fireBalls();
      }
    });

    // Compute exitAngle for Portal B from pointer coords
    function setPortalBAngleFromPointer(px, py) {
      if (!portalB) return;
      const cx = portalB.x + portalB.width / 2;
      const cy = portalB.y + portalB.height / 2;
      portalB.exitAngle = Math.atan2(py - cy, px - cx);
    }

    // ======= 7. “Place Portals” Button Handling =======
    const placePortalsBtn = document.getElementById("placePortalsBtn");
    placePortalsBtn.addEventListener("click", () => {
      if (portalPlacementActive) return;
      portalPlacementActive = true;
      nextPortalType = "A";
      placePortalsBtn.textContent = "Place Portal A";
    });

    // ======= 8. Overlay Button Handlers =======
    document.getElementById("restartBtn").addEventListener("click", () => {
      initGame();
    });
    document.querySelectorAll(".backBtn").forEach((btn) => {
      btn.addEventListener("click", () => {
        document.getElementById("howToScreen").classList.add("hidden");
        document.getElementById("settingsScreen").classList.add("hidden");
        document.getElementById("creditsScreen").classList.add("hidden");
      });
    });

    // ======= 9. Start Everything =======
    initGame();
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
